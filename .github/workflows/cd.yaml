name: CD

on:
  workflow_dispatch: {}

env:
  CLUSTER_NAME: "eks-postech-g57-railson"
  AWS_REGION: "us-east-1"
  NAMESPACE: "payments"

jobs:
  setup-aws-secrets:
    runs-on: ubuntu-latest
    env:
      SECRET_NAME: "production/payments"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get AWS Account ID and Role ARN
        id: aws-info
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          
          # Buscar a role de secrets manager - nome fixo baseado no cluster
          ROLE_NAME="${{ env.CLUSTER_NAME }}-secrets-manager-access"
          ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query "Role.Arn" --output text 2>/dev/null || echo "")
          
          if [ -z "$ROLE_ARN" ] || [ "$ROLE_ARN" == "None" ]; then
            echo "ERROR: Role $ROLE_NAME not found!"
            exit 1
          fi
          
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
          
          echo "AWS Account ID: $ACCOUNT_ID"
          echo "Role ARN: $ROLE_ARN"
      
      - name: Setup AWS Secrets Manager
        run: |
          SECRET_VALUE='{"JWT_TOKEN_PIX_APPLICATION_PAYMENT":"${{ secrets.JWT_TOKEN_PIX_APPLICATION_PAYMENT }}"}'
          
          # Check if secret exists
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" 2>/dev/null; then
            echo "Secret exists, updating..."
            aws secretsmanager update-secret \
              --secret-id "$SECRET_NAME" \
              --secret-string "$SECRET_VALUE"
          else
            echo "Secret does not exist, creating..."
            aws secretsmanager create-secret \
              --name "$SECRET_NAME" \
              --secret-string "$SECRET_VALUE"
          fi
          
          echo "Secret $SECRET_NAME successfully configured"
      
      - name: Update and Apply ServiceAccount
        run: |
          # Obter o ARN da role
          ROLE_ARN="${{ steps.aws-info.outputs.role_arn }}"
          echo "Role ARN a ser usado: $ROLE_ARN"
          
          # Configurar kubectl
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          
          # Criar ServiceAccount diretamente via kubectl (sem arquivo template)
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: ${{ env.NAMESPACE }}-service-account
            namespace: ${{ env.NAMESPACE }}
            annotations:
              eks.amazonaws.com/role-arn: ${ROLE_ARN}
          EOF
          
          echo "ServiceAccount applied successfully"

  call-reusable-deploy-workflow:
    needs: setup-aws-secrets
    uses: railsonribeiro/nested-reusable-java-maven-eks-fork/.github/workflows/deploy.yml@main
    with:
      cluster_name: "eks-postech-g57-railson"
      app_name: "payments-api"
      namespace: "payments"
      git_repo_url: "https://github.com/railsonribeiro/pos-tech-g57-app-payments-forked"
    secrets: inherit
